# 线程
进程是程序的一次执行，但这些功能显然不可能是由一个程序顺序处理就能实现的

由的进程可能需要 同时 做很多事情，二传统的进程只能串行地执行一系列程序。为此，引入了 线程 来增加并发度

引入线程后，线程成为了程序执行流的最小单位，线程也是一个基本的CPU执行单元 (线程就是轻量级进程)。不仅仅进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提高了系统的并发度，是的一个进程内也可以并发处理各种任务。

引入线程后，进程只作为除CPU之外的系统资源的分配单元

## 带来的变化
1. 资源分配、调度
    - 传统进程机制中，进程是资源分配、调度的基本单位
    - 引入线程后，进程是资源分配的基本单位，线程是调度的基本单位
2. 并发性
    - 传统进程机制中，只能进程间并发
    - 引入线程后，各线程间也能并发，提升了并发度
3. 系统开销
    - 传统的进程间并发，需要切换进程的运行环境，系统开销很大
    - 线程间并发，如果是统一进程内的线程切换则不需要切换环境，系统开销小
    - 引入线程后，并发带来的系统开销减小

## 线程的属性
1. 线程是处理及调度的单位
2. 多CPU计算机中，各个线程可占用不同的CPU
3. 每个线程都有一个线程ID、线程控制块(TCB)
4. 线程也有就绪、阻塞、运行三种基本状态
5. 线程几乎不拥有系统资源
6. 同一进程的不同线程间共享进程的资源
7. 由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预
8. 同一进程中的线程切换不会引起进程切换
9. 不同进程中的线程切换回引起进程切换
10. 切换同进程内的线程，系统开销很小
11. 切换进程，系统开销大

## 线程的实现方式

#### 用户级线程
早期的操作系统只支持进程，不支持线程。当时的”线程“是用线程库实现的
#### 内核级线程
操作系统支持的线程，现在大多数的操作系统都支持了内核级的线程

内核级线程的管理工作是由操作系统来完成的，并且操作系统能意识到内核级线程的存在

## 多线程模型
#### 1:1
一个用户级线程映射到一个内核级线程。每个用户进程由与用户级线程同数量的内核级线程

优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行

缺点：一个用户进程回占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态。因此线程管理成本高，开销大
#### n:1
多个用户级线程映射到一个内核级线程。且一个进程制只被分配一个内核级线程

优点：用户级线程的切换在用户空间内即可完成，不需要切换到核心态。线程管理的系统开销小，效率高

缺点：当要给用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可以在多核处理机上并行运行

！！！！ 操作系统只能感知到内核级线程，因此只有内核级线程是处理机分配的单位
#### n:m
n用户线程映射到m个内核级线程 n>=m. 每个用户进程对应m个内核级线程。

克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点

## 线程的状态与转换
我们只关注线程的 就绪-运行-阻塞 三个状态的转换

巧了  这个状态转换和进程的一摸一样

## 线程的组织与控制
这里也和进程很类似，进程有PCB，线程有TCB

TCB
[          线程标识符->TID(同PID)         ]
[      程序计数器PC->线程目前执行到哪里     ]
[       其他寄存器->线程运行的中间结果      ]
[ 堆栈指针->对战保存函数调用信息、局部变量等 ]
[               线程运行状态              ]
[        优先级->线程调度、资源分配的参考   ]

第二三四就是线程切换的时候需要保存和恢复的寄存器的内容